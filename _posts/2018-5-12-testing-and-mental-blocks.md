---
layout: post
title: Testing and Breaking Through Mental Blocks
---

I recently went through a job search process and went on a lot of interviews.  Similar questions often come up in engineering interviews across companies, and some of them were actually really helpful because they made me articulate some of the ways I go about doing my day to day work that I hadn't before.  After several years of working as a software engineer at three different companies writing many different languages, I've built up a some habits and techniques that I'm barely even conscious of.  Finding ways to explain those habits and techniques gave me good material to talk about in interviews for the "soft skills" questions, and I think it also gave me some clarity on how I can be more productive at work.

One thing that kept coming up for me was how I use testing.  Sometimes the question was directly related to testing like "how do you approach testing?", but sometimes the question was "how do you approach breaking down a problem", or "what do you do when you feel stuck on a problem", or even "what is your biggest weakness?".  And I found myself reaching for how I use testing to answer all of those.

My answers to those questions were all a variation of "I like to use tests to help me get through mental blocks".  I have noticed that one of my "biggest weaknesses" (or just a tendency of mine that bugs me, whatever) is that I tend to circle around problems a lot.  I read a lot of code, think a lot, and read more code before I ever start writing anything.  I don't think this is necessarily a bad thing because the other end of the spectrum is writing a bad implementation and being reluctant to delete it, but sometimes I do end up having to force myself to start implementing things because circling the problem is no longer productive.  Part of the issue is that I try to keep too much in my head, part of it is fear of making the wrong implementation decision, but my own tendency to delay writing code gets worse with big problems.  At Kickstarter, I circled around the problem of doing a rewrite of our checkout flow for literally months before finally sitting down and writing it within a week.  I'm proud of the final product, but I knew the right decision for months before implementing and shipping it.  

I've found one of the best ways to get myself unstuck on issues is tests.  It's actually the opposite of the TDD tactic "write some tests for the interface you want the object to have" because that doesn't solve the problem of trying to keep too much in my head.  I think that's part of the reason TDD has never really clicked for me (or anyone I've worked with, frankly): it doesn't help break the problem down.  

What I've found much effective is implement the smallest piece of functionality I can think of for the task I want to accomplish and write a test for it.  Even if it's something trivial - the goal for me is to eliminate small pieces of the larger problem so I can stop thinking about them.  Complex integration tests that touch the database or require complex setups are not idea here because they are complex by themselves.  It's unlikely that a large integration test is going to be helpful when I am hitting a wall in implementation because they test several layers of the stack.  Also, I think part of the benefit of this whole strategy is the quick feedback loop that tests can give me, and spending hours writing an integration test doesn't do that.  

My experience working with and being a part of the Kickstarter mobile team writing [functional, reactive code][1] helped me refine this a lot.  Even in non-functional codebases, the tactic of breaking down complex problems into the smallest pieces of composable functionality that can be tested helps me stop circling the problem and start solving it.  Once you have a tiny part done, you can write another tiny part, and you can eventually start composing your tiny parts into solving your larger problem while feeling secure that you already solved a bunch of your tiny problems.  It's like you're climbing a ladder (or building ladder even), and you don't have to worry about the rungs below you.  You can just focus on what's above you.

I write tests in other contexts too: to confirm that functionality I wrote is working correctly, to prevent regressions, and to give myself mental peace.  I've just found it a very effective tactic for solving my own issues with circling around problems that are too big to keep in my head.  There's also the added satisfaction of feeling like I've made progress on an issue once I get at least a tiny problem solved.  Solving a small problem goes a long way towards giving me more motivation to solve the big one.

[1]: https://github.com/kickstarter/android-oss