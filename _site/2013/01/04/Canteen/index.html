<!DOCTYPE HTML>

<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="author" content="Your Name" />
      <link rel="stylesheet" href="/css/bootstrap/css/bootstrap.css">
      <link rel="stylesheet" href="/css/pygments.css">
      <style type='text/css'>
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .brand {
        font-family: Open Sans;
      }
      .nav {
        font-size: 1.1em;
      }
      .footer {
        position: relative; 
        bottom: 0; 
        left: 0; 
        width: 100%; 
        text-align: center;
      }
      </style>
      <link rel="stylesheet" href="/css/bootstrap/css/bootstrap-responsive.css">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <script type="text/javascript">
    //google analytics
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37478382-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

</script>
    <title>Framework Reflections</title>
  </head>
<body>
    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">Julie Swoope   </a>
          <div class="nav-collapse">
          <ul class="nav">
          <li><a href="/about.html">About</a></li>
          <li><a href="/projects.html">Projects</a></li>
          <li><a href="/archive.html">Archive</a></li>
          <li><a href="http://github.com/swoopej">Github</a></li>
        </div>
      </div>
    </div>
  </div>


  <div class="row"><br>
  <div class="span8 offset2">
    <div class="content">
      <body>
<div class="post">
    <h1></h1>
    <p><h1>Canteen</h1>

<p>I wanted to write a reflection on the work that I have done so far on <a href="https://github.com/swoopej/canteen" title="Canteen">Canteen</a>, a web framework that I have been working on building from scratch at Hacker School.  I should add up front that not all of the work is mine, I've been working with fellow Hacker Schooler <a href="https://github.com/angusb" title="Angus Github">Angus Burton</a>, and he's certainly helped in ways that I couldn't have done myself.</p>

<p>So the first thing that I learned about is the Web Server Gateway Interface, or WSGI.  I had seen this abbreviation before in the configuration file for Django apps, but it sounded pretty opaque, and I knew that I didn't have to change the default to make my app work, so I occupied myself with other things.</p>

<p>It turns out WSGI is hardly complicated.  It's just a way for the server and the framework or application to communicate, and it's much less complicated form of communication than something like HTTP, which is a protocol that has to be compatible across many platforms.  WSGI only applies to Python servers and Python apps, so the scope is limited and concise.</p>

<p>The gist of it is that a WSGI server will call a WSGI app with two variables when it receives a request.  One is an <a href="http://www.python.org/dev/peps/pep-0333/#environ-variables" title="#environ">environment dictionary</a> containing information about the request and the server environment, and the other is a function that must be called by the WSGI framework to start the response on the server.  It's really remarkably simple.  So a simple WSGI app using the Python Standard Library WSGI server looks something like this:</p>

<div class="highlight"><pre><code class="python">    <span class="kn">from</span> <span class="nn">wsgiref.simple_server</span> <span class="kn">import</span> <span class="n">make_server</span>

    <span class="k">class</span> <span class="nc">Canteen</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">run_server</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c">#instantiate the wsgi server</span>
        <span class="c">#receives request, passes to wsgi app</span>
        <span class="c">#send app&#39;s response to client</span>
        <span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span>
            <span class="s">&#39;localhost&#39;</span><span class="p">,</span> 
            <span class="mi">8051</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wsgi_app</span> <span class="c">#calls the WSGI app</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">wsgi_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            called by the server with the environ dict and the start_response function</span>

<span class="sd">            start_response must be called to start the http response.  </span>

<span class="sd">            This function will</span>
<span class="sd">            return the response body as an iterable.</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">response</span> <span class="n">body</span> <span class="o">=</span> <span class="s">&#39;yolo&#39;</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s">&#39;200 OK&#39;</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Content_Type&#39;</span><span class="p">,</span> <span class="s">&#39;text/html&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;Content_Length&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">response_body</span><span class="p">)))]</span>
            <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">response_body</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">Canteen</span><span class="p">()</span>
        <span class="n">app</span><span class="o">.</span><span class="n">run_server</span><span class="p">()</span>

    
</code></pre></div>


<p>And that's it.  Run that on your local machine, and you will be told that you only live once when you go to port 8051.</p>

<p>The second thing I'll talk about in this post is how we built the interface to our framework, which is nearly identical to that of Flask, another Python framework (side note here:  after digging around in the Flask code for days, it is, in the words of Angus, "quite slick").</p>

<p>I've built a few small apps in Flask, and it's awesome how quickly you can get an app running.  To add a url to your app in Flask, all it takes is this:</p>

<div class="highlight"><pre><code class="python">    <span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">()</span>

    <span class="nd">@app.route</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
        <span class="n">render_template</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">html</span><span class="p">)</span>
    
</code></pre></div>


<p>and we managed to copy the same syntax (minus the render_template method for now).  Here's how we did it:</p>

<div class="highlight"><pre><code class="python">    <span class="k">def</span> <span class="nf">add_route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">methods</span><span class="o">=</span> <span class="s">&#39;GET&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;decorates a user supplied function by adding path to self.routes&#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Route</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">methods</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">routes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decorator</span>
    
</code></pre></div>


<p>The decorator creates a new Route object and stores the path, the valid HTTP methods, and the function to be called on the Route object.  That new object is added to the list of Route objects at self.routes, and the decorator function is returned.  When a new HTTP request comes in, framework will go through the Route objects, find the right one, and call the function stored on that objects.  If it doesn't find the right one, you get a 404.</p>

<p>I'll talk about how we search for the correct route object in another post, but I wanted to chime and praise Flask again for how lightweight it is.  While starting an app in Django takes at least five different files, you can import Flask into one file and get quite a bit of functionality out of it.  That's what I hope to reproduce with Canteen.</p>
</p>
</div>
</div>
</body>





    </div>
  </div>
</div>
    <div class="row"><br>
    <div class="span12 offset2"><br>
        <div class="footer">
            <p>   Created with <a href="https://github.com/mojombo/jekyll">Jekyll</a> and <a href="http://twitter.github.com/bootstrap/">Bootstrap</p>
        </div> <!-- close footer -->
        </div>
    </div>

    </body>
</html>

